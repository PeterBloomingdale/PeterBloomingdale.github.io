[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "I was looking for a free photo online to use in my blog and just decided to take one myself. Currently, writing this post with a nice view of the city of Boston/Cambridge, despite the gloomy weather. One thing on the to-do list is to learn how to build an image generator using AI to create my own images or use an already developed model. I’ll likely start by playing around with Stable Diffusion 2.\n\nQuarto\nOver the past year, I have learned many new programming languages and softwares. Earlier this year, Quarto was released. This has commonly been referred to as “R Markdown v2.0”. I highly recommend adding this tool to your toolbox as there are a range of useful applications. I have personally used Quarto for writing manuscripts, taking notes during online courses, documenting model/code, and creating websites (this blog!). I wish this was around when I was writing my PhD thesis!"
  },
  {
    "objectID": "posts/ChatGPT/ChatGPTPMx.html",
    "href": "posts/ChatGPT/ChatGPTPMx.html",
    "title": "ChatGPT: Applications in Pharmacometrics",
    "section": "",
    "text": "A technology as disruptive as the internet…\nChatGPT is not quite there, but I would make this statement about generative artifical intelligence (AI). ChatGPT, although far from perfect, provides a nice proof-of-concept for the power of transformer technology and large language models. I have provided the short dialog relating to applications in pharmacometrics. In short, the jobs of pharmacometricians are not in jeopardy in the near term. Perhaps the only benefit of our field being so closed-door when it comes to model/code/data sharing haha (painfully laughing).\nChatGPT Summary:\n\nOne Compartment PK Model (Explicit) - Fail\nOne Compartment PK Model (ODEs) - Pass\nTwo Compartment PK Model (ODEs) - Pass\nPhysiologically-Based PK Model - Fail\nMinimal Physiologically-Based PK Model - Fail\nQuantitative Systems Pharmacology Model - Fail"
  },
  {
    "objectID": "posts/ChatGPT/ChatGPTPMx.html#chatgpt-conversion",
    "href": "posts/ChatGPT/ChatGPTPMx.html#chatgpt-conversion",
    "title": "ChatGPT: Applications in Pharmacometrics",
    "section": "ChatGPT Conversion",
    "text": "ChatGPT Conversion\nBelow is the exact dialog that I had with ChatGPT\n\nBold is the text entered into the ChatGPT input box\nItalics is my commentary\nAll other text is ChatGPTs response\n\n\n\nQ1: One-Compartment PK Model\nPeter:\nIn R, write a one-compartment pharmacokinetic model\n\nChatGPT:\nIn R, you can create a one-compartment pharmacokinetic model using the following code:\n# Define function for one-compartment model\noneCompartmentModel <- function(dose, k) {\n  # Create empty vector to store concentrations over time\n  concentrations <- c()\n  \n  # Set initial concentration to 0\n  concentrations[1] <- 0\n  \n  # Loop through time points and calculate concentrations\n  for (i in 2:length(time)) {\n    # Calculate concentration at current time point\n    concentrations[i] <- concentrations[i - 1] + dose * k * (1 - exp(-k * (time[i] - time[i - 1])))\n  }\n  \n  # Return concentrations\n  return(concentrations)\n}\n\n# Define time points and dose\ntime <- seq(0, 24, 0.1)\ndose <- 100\n\n# Define elimination rate constant (k)\nk <- 0.1\n\n# Run the model\nconcentrations <- oneCompartmentModel(dose, k)\nThis code defines a function oneCompartmentModel() that takes the dose and the elimination rate constant (k) as input and returns a vector of concentrations over time. The function uses a simple one-compartment model to calculate the concentrations at each time point by looping through the time points and updating the concentration at each time point based on the previous concentration and the dose and k values. The function returns the vector of concentrations, which can then be plotted or analyzed further.\n\nPeter:\nThis code executes, but the output does not make sense. See figure below\n\n\n\n\nFigure 1: ChatGPT One-Compartment Pharmacokinetic Model\n\n\n\nThe equation is incorrect. There are clear dimensionality problems with the equation (e.g., concentration + dose/time). The equation is explicit, does not use differential equations. Perhaps it got confused between a one-compartment PK model for IV versus oral administration, mixing up parameters for the first-order rate constant of elimination (k) and absorption (ka). One-compartment IV (equation 1) and oral absorption (equation 2) PK model equations shown below:\n\\[\\begin{equation}\nC(t) = C_{0} \\cdot e^{-k \\cdot t}\n\\end{equation}\\]\n\\[\\begin{equation}\nC(t) = \\frac{F \\cdot Dose \\cdot k_{a}}{(k_{a} - k_{e}) \\cdot V}(e^{-k_{e} \\cdot t} - e^{-k_{a} \\cdot t})\n\\end{equation}\\]\nHowever, it was cool to see that a function was created, parameters/dose were defined, and a for-loop was used to generate a vector of concentrations based on input variables (dose, k). A bit surprised that the equation was explicit and differential equations were not used.\n\n\n\nQ2: One-Compartment PK Model (ODEs)\nPeter:\nIn R, write a one-compartment pharmacokinetic model using ODEs\n\nChatGPT:\nIn R, you can create a one-compartment pharmacokinetic model using ordinary differential equations (ODEs) with the following code:\n# Define function for one-compartment model using ODEs\noneCompartmentModelODE <- function(time, init, params) {\n  with(as.list(c(init, params)), {\n    # Calculate rate of change in concentration\n    dA <- -k * A\n    \n    # Return rate of change\n    return(list(dA))\n  })\n}\n\n# Define initial conditions and parameters (Original)\ninit <- c(A = 0)\nparams <- c(k = 0.1)\n\n\n# Define initial conditions and parameters (Updated)\ninit <- c(A = 100)\nparams <- c(k = 0.1)\ntime <- seq(0, 24, 0.1)\n\n# Use ode to solve the system of ODEs\noutput <- ode(func = oneCompartmentModelODE, y = init, times = time, parms = params)\n\n# Extract concentration values from output\nconcentrations <- output[, \"A\"]\nThis code defines a function oneCompartmentModelODE() that takes the time points, initial conditions, and parameters as input and uses the ode() function from the deSolve package to solve the system of ODEs for the one-compartment model. The function returns a matrix of output values, which can then be used to extract the concentrations over time. The code then uses the ode() function to solve the ODEs for the specified time points and parameters, and extracts the concentrations from the output. These concentrations can then be plotted or analyzed further.\n\nPeter:\nThe code executes (with minor changes) and the equations are correct (Figure 2). The ode() function used requires the deSolve package to be installed. The “# Define initial conditions and parameters” block needed to be updated to include the variable, which was missing in the original code. Additionally, initial concentration was set to 0, which I changed to 100. Small note the variable name “A” typically refers to an amount, but here it was defined as a concentration.\n\n\n\n\nFigure 2: ChatGPT One-Compartment Pharmacokinetic Model (ODEs)\n\n\n\n\n\n\nQ3: Two-Compartment PK Model (ODEs)\nPeter:\nIn R, write a two-compartment pharmacokinetic model using ODEs\n\nChatGPT:\n# Define function for two-compartment model using ODEs\ntwoCompartmentModelODE <- function(time, init, params) {\n  with(as.list(c(init, params)), {\n    # Calculate rate of change in concentrations in each compartment\n    dA1 <- -(k12 + k10) * A1 + k21 * A2\n    dA2 <- k12 * A1 - k21 * A2\n    \n    # Return rates of change\n    # return(list(dA1, dA2)) # Original\n    return(list(c(dA1, dA2))) # Updated\n  })\n}\n\n# Define initial conditions and parameters (Original)\ninit <- c(A1 = 0, A2 = 0)\nparams <- c(k12 = 0.1, k21 = 0.2, k10 = 0)\n\n# Define initial conditions and parameters (Updated)\ninit <- c(A1 = 100, A2 = 0)\nparams <- c(k12 = 0.1, k21 = 0.2, k10 = 0.1)\ntime <- seq(0, 24, 0.1)\n\n# Use ode to solve the system of ODEs\noutput <- ode(func = twoCompartmentModelODE, y = init, times = time, parms = params)\n\n# Extract concentration values from output\nconcentrations1 <- output[, \"A1\"]\nconcentrations2 <- output[, \"A2\"]\nThis code defines a function twoCompartmentModelODE() that takes the time points, initial conditions, and parameters as input and uses the ode() function from the deSolve package to solve the system of ODEs for the two-compartment model. The function returns a matrix of output values, which can then be used to extract the concentrations in each compartment over time. The code then uses the ode() function to solve the ODEs for the specified time points and parameters, and extracts the concentrations from the output. These concentrations can then be plotted or analyzed further.\n\nPeter:\nThis code executes (with minor changes) and the equations are correct. Again, time was not defined. The initial concentration of C1 was 0 and the rate of elimination (k10) from the central compartment was 0. These values were updated for the simulation.\n\n\n\n\nFigure 3: ChatGPT Two-Compartment Pharmacokinetic Model (ODEs)\n\n\n\nThere was an error upon execution that I had asked ChatGPT to resolve. The error was eventually solved by concatenating the outputs in the return statement (c(dA1, dA2)) of the twoCompartmentModelODE function. However, ChatGPT was unable to resolve the error and kept providing the same response without any changes. The dialog is provided below:\nYour code gave me the following error, please help me solve it.\nError in checkFunc(Func2, times, y, rho): The number of derivatives returned by func() (1) must equal the length of the initial conditions vector (2) Calls: ode -> lsoda -> checkFunc Execution halted \n\nChatGPT:\nThis error message indicates that the ode() function is expecting the twoCompartmentModelODE() function to return two values (one for each compartment), but it is only returning one value (the rate of change in the first compartment). To fix this error, you need to modify the twoCompartmentModelODE() function to return both rates of change, like this:\n# Define function for two-compartment model using ODEs\ntwoCompartmentModelODE <- function(time, init, params) {\n  with(as.list(c(init, params)), {\n    # Calculate rate of change in concentrations in each compartment\n    dA1 <- -(k12 + k10) * A1 + k21 * A2\n    dA2 <- k12 * A1 - k21 * A2\n    \n    # Return rates of change\n    return(list(dA1, dA2))\n  })\n}\nIn this updated version of the function, the return() statement includes both rates of change, separated by a comma. This will ensure that the ode() function receives the correct number of values and can solve the system of ODEs correctly.\n\n\n\nQ4: Physiologically-Based Pharmacokinetic (PBPK) Model\nPeter:\nIn R, code a physiologically-based pharmacokinetic model\n\nChatGPT:\nIn R, you can create a physiologically-based pharmacokinetic (PBPK) model using the following code:\n# Define function for PBPK model\npbpkModel <- function(time, init, params) {\n  with(as.list(c(init, params)), {\n    # Calculate rate of change in concentrations in each compartment\n    dA1 <- -(k12 + k10) * A1 + k21 * A2\n    dA2 <- k12 * A1 - k21 * A2\n    \n    # Calculate liver and kidney clearance\n    liverClearance <- Q * kLiver\n    kidneyClearance <- Q * kKidney\n    \n    # Calculate rate of change in drug amount in liver and kidneys\n    dLiver <- liverClearance - k10 * A1\n    dKidney <- kidneyClearance - k10 * A2\n    \n    # Return rates of change\n    #return(list(dA1, dA2, dLiver, dKidney)) # Original\n    return(list(c(dA1, dA2, dLiver, dKidney))) # Updated\n  })\n}\n\n# Define initial conditions and parameters (Original)\ninit <- c(A1 = 0, A2 = 0, liver = 0, kidney = 0)\nparams <- c(k12 = 0.1, k21 = 0.2, k10 = 0, kLiver = 0.3, kKidney = 0.4, Q = 1)\n\n# Define initial conditions and parameters (Updated)\ninit <- c(A1 = 100, A2 = 0, liver = 0, kidney = 0)\nparams <- c(k12 = 0.1, k21 = 0.2, k10 = 0.1, kLiver = 0.3, kKidney = 0.4, Q = 1)\ntime <- seq(0, 24, 0.1)\n\n# Use ode to solve the system of ODEs\noutput <- ode(func = pbpkModel, y = init, times = time, parms = params)\n\n# Extract concentration values from output\nconcentrations1 <- output[, \"A1\"]\nconcentrations2 <- output[, \"A2\"]\nliverConcentrations <- output[, \"liver\"]\nkidneyConcentrations <- output[, \"kidney\"]\nThis code defines a function pbpkModel() that takes the time points, initial conditions, and parameters as input and uses the ode() function from the deSolve package to solve the system of ODEs for the PBPK model. The function calculates the rates of change in the concentrations in each compartment, as well as the liver and kidney clearances and the amounts of drug in the liver and kidneys. It then returns these values, which can be used by the ode() function to solve the ODEs. The code then uses the ode() function to solve the ODEs for the specified time points and parameters, and extracts the concentrations and drug amounts from the output. These values can then be plotted or analyzed further.\n\nPeter:\nThis code executes (with minor changes), but the equations are incorrect. Time was not defined and initial conditions needed to be initialized, values were updated for the simulation. The same error, which requires concatenating the outputs in the return statement needed to be resolved. The PBPK model generated by ChatGPT is essentially a two-compartment model with a kidney and liver compartment added. However, the liver and kidney equations are completely off and do not make sense. The simulations resulted in negative concentrations in liver and kidney compartments. Quite disappointing…\n\n\n\n\nFigure 4: ChatGPT Physiologically-Based Pharmacokinetic Model\n\n\n\n\n\n\nQ5: Minimal Brain Physiologically-Based Pharmacokinetic (PBPK) Model\nPeter:\n*Perhaps being more specific on the type of PBPK model could help. Also wondering if it was trained using the scientific literature. In one of my papers (minimal brain PBPK model) I have published the model code in the supplementary information, but I doubt that was used. Lets find out. We will have to ask it to code it in MATLAB as well.\nIn R, code a minimal brain physiologically-based pharmacokinetic (PBPK) model that can be used to to support the preclinical and clinical development of antibody therapeutics for CNS diseases\n\nChatGPT\nIn R, you can create a minimal brain physiologically-based pharmacokinetic (PBPK) model using the following code:\n# Define function for PBPK model\npbpkModel <- function(time, init, params) {\n  with(as.list(c(init, params)), {\n    # Calculate rate of change in concentrations in each compartment\n    dA1 <- -(k12 + k10) * A1 + k21 * A2\n    dA2 <- k12 * A1 - k21 * A2\n    dBrain <- -k10 * ABrain + k21 * CBrain\n    \n    # Calculate liver and kidney clearance\n    liverClearance <- Q * kLiver\n    kidneyClearance <- Q * kKidney\n    \n    # Calculate rate of change in drug amount in liver and kidneys\n    dLiver <- liverClearance - k10 * A1\n    dKidney <- kidneyClearance - k10 * A2\n    \n    # Return rates of change\n    return(list(dA1, dA2, dBrain, dLiver, dKidney))\n  })\n}\n\n# Define initial conditions and parameters\ninit <- c(A1 = 0, A2 = 0, ABrain = 0, liver = 0, kidney = 0)\nparams <- c(k12 = 0.1, k21 = 0.2, k10 = 0, kLiver = 0.3, kKidney = 0.4, Q = 1)\n\n# Use ode to solve the system of ODEs\noutput <- ode(func = pbpkModel, y = init, times = time, parms = params)\n\n# Extract concentration values from output\nconcentrations1 <- output[, \"A1\"]\nconcentrations2 <- output[, \"A2\"]\nbrainConcentrations <- output[, \"ABrain\"]\nliverConcentrations <- output[, \"liver\"]\nkidneyConcentrations <- output[, \"kidney\"]\nThis code defines a function pbpkModel() that takes the time points, initial conditions, and parameters as input and uses the ode() function from the deSolve package to solve the system of ODEs for the PBPK model. The function calculates the rates of change in the concentrations in each compartment, as well as the liver and kidney clearances and the amounts of drug in the liver and kidneys. It also includes a compartment for the brain, and calculates the rate of change in drug concentration in the brain based on the drug concentrations in the other compartments. It then returns these values, which can be used by the ode() function to solve the ODEs. The code then uses the ode() function to solve the ODEs for the specified time points and parameters, and extracts the concentrations and drug amounts from the output. These values can then be plotted or analyzed further.\n\nPeter:\n*Okay, real bad… lol. It appears that the previous PBPK model that ChatGPT generated was extended to include a differential equation for the brain that has terms in both amounts and concentrations. How about MATLAB?\nIn R, code a minimal brain physiologically-based pharmacokinetic (PBPK) model that can be used to to support the preclinical and clinical development of antibody therapeutics for CNS diseases\n\nChatGPT:\nIn MATLAB, you can create a minimal brain physiologically-based pharmacokinetic (PBPK) model using the following code:\nfunction dydt = pbpkModel(t, y, k12, k21, k10, kLiver, kKidney, Q)\n  % Calculate concentrations in each compartment\n  A1 = y(1);\n  A2 = y(2);\n  ABrain = y(3);\n\n  % Calculate rate of change in concentrations in each compartment\n  dA1 = -(k12 + k10) * A1 + k21 * A2;\n  dA2 = k12 * A1 - k21 * A2;\n  dBrain = -k10 * ABrain + k21 * CBrain;\n\n  % Calculate liver and kidney clearance\n  liverClearance = Q * kLiver;\n  kidneyClearance = Q * kKidney;\n\n  % Calculate rate of change in drug amount in liver and kidneys\n  dLiver = liverClearance - k10 * A1;\n  dKidney = kidneyClearance - k10 * A2;\n\n  % Return rates of change\n  dydt = [dA1; dA2; dBrain; dLiver; dKidney];\nend\nThis code defines a function pbpkModel() that takes the time points, initial conditions, and model parameters as input and calculates the rates of change in the concentrations in each compartment. It also includes a compartment for the brain, and calculates the rate of change in drug concentration in the brain based on the drug concentrations in the other compartments. The function returns the rates of change, which can then be used by the ode45() function in MATLAB to solve the ODEs.\nTo solve the ODEs and plot the results, you can use the following code:\n% Define initial conditions and parameters\ninit = [0, 0, 0];\nk12 = 0.1;\nk21 = 0.2;\nk10 = 0;\nkLiver = 0.3;\nkKidney = 0.4;\nQ = 1;\n\n% Define time points\ntime = linspace(0, 24, 240);\n\n% Solve the ODEs\n[t, y] = ode45(@(t, y) pbpkModel(t, y, k12, k21, k10, kLiver, kKidney, Q), time, init);\n\n% Extract concentration values from solution\nA1 = y(:, 1);\nA2 = y(:, 2);\nABrain = y(:, 3);\n\n% Plot the results\nplot(t, A1, 'b', t, A2, 'r', t, ABrain, 'g');\nxlabel('Time (hours)');\nylabel('Concentration (mg/L)');\nlegend('Compartment 1', 'Compartment 2', 'Brain');\nThis code defines the initial conditions and model parameters, and uses the ode45() function to solve the ODEs for the specified time points. It then extracts the concentrations in each compartment from the solution and plots them using the plot() function. The resulting plot shows the concentrations in each compartment over time.\n\nPeter:\nVery disappointing, but at least ChatGPT appologized…\nThis is very incorrect code, can you develop a better physiologically-based pharmacokinetic model of the brain in any language\n\nChatGPT:\nI apologize if the previous code was not correct or complete. Developing a physiologically-based pharmacokinetic (PBPK) model of the brain is a complex task that requires a thorough understanding of the underlying physiology and pharmacokinetic principles, as well as the specific drug being modeled and its mechanism of action. It is not possible for me to provide a complete and accurate PBPK model of the brain in a brief response like this.\nHowever, I can provide some general guidelines and ideas for how to develop a PBPK model of the brain. Some key steps in the process might include:\n\nIdentify the compartments and pathways that are relevant to the brain, including the blood-brain barrier, cerebrospinal fluid, and other key anatomical structures.\nDevelop a system of ordinary differential equations (ODEs) that describes the transfer of the drug between these compartments and the body as a whole. This will typically involve using mass balance equations to describe the rate of change in drug concentration in each compartment.\nDefine the initial conditions and model parameters, such as the drug’s distribution and elimination rates, and the characteristics of the compartments and pathways.\nUse numerical methods, such as the ode45() function in MATLAB, to solve the ODEs and generate predictions of the drug’s concentration in the brain over time.\nValidate the model by comparing the predictions to experimental data, and make adjustments to the model as needed to improve its accuracy.\nUse the validated model to simulate different dosing scenarios and study the effects of various factors on the drug’s pharmacokinetics in the brain. This can provide valuable insights into the drug’s pharmacokinetics and help support the preclinical and clinical development of brain-targeted therapies.\n\nUltimately, the development of a PBPK model of the brain will require a deep understanding of the relevant physiology, pharmacokinetics, and drug properties, as (end of response)\n\n\n\nQuestion 6: Quantitative Systems Pharmacology (QSP) Model\nPeter:\nQuite the long shot, but I am curious how far it gets\nCode a quantiative systems pharmacology (QSP) model of Alzheimer’s disease\n\nChatGPT\nDeveloping a quantitative systems pharmacology (QSP) model of Alzheimer’s disease is a complex task that requires a thorough understanding of the underlying biology and pharmacology of the disease, as well as the specific drugs and mechanisms of action being modeled. It is not possible for me to provide a complete and accurate QSP model of Alzheimer’s disease in a brief response like this.\nHowever, I can provide some general guidelines and ideas for how to develop a QSP model of Alzheimer’s disease. Some key steps in the process might include:\n\nIdentify the key biological pathways and mechanisms involved in Alzheimer’s disease, such as the accumulation of beta-amyloid plaques and the dysregulation of neurotransmitter systems.\nDevelop a systems-level mathematical model that describes the interactions and feedback loops between these pathways and mechanisms. This will typically involve using ordinary or partial differential equations to describe the dynamics of the key variables and parameters in the model.\nDefine the initial conditions and model parameters, such as the rates of production and clearance of beta-amyloid, the levels of neurotransmitters, and the effects of genetic and environmental factors on the disease.\nUse numerical methods, such as the ode45() function in MATLAB, to solve the equations and generate predictions of the disease’s progression over time.\nValidate the model by comparing the predictions to experimental data, and make adjustments to the model as needed to improve its accuracy.\n\n\nPeter:\nTry your best at developing model code for a quantitative systems pharmacology model of Alzheimer’s disease using differential equations\n__\nChatGPT\nDeveloping a quantitative systems pharmacology (QSP) model of Alzheimer’s disease using differential equations is a complex task that requires a thorough understanding of the underlying biology and pharmacology of the disease, as well as the specific drugs and mechanisms being modeled. It is not possible for me to provide a complete and accurate QSP model of Alzheimer’s disease in a brief response like this.\nHowever, I can provide some general guidelines and ideas for how to develop a QSP model of Alzheimer’s disease using differential equations. Some key steps in the process might include:\n\nIdentify the key biological processes and mechanisms that are involved in Alzheimer’s disease, such as amyloid beta aggregation, tau phosphorylation, and inflammation.\nDevelop a system of ordinary differential equations (ODEs) that describes the dynamics of these processes and their interactions. This could involve using mass balance equations to describe the rate of change in key biological markers, such as amyloid beta and tau, as well as the effects of drugs on these processes.\nDefine the initial conditions and model parameters, such as the baseline levels of key biological markers and the drug’s pharmacokinetic and pharmacodynamic properties.\nUse numerical methods, such as the ode45() function in MATLAB, to solve the ODEs and generate predictions of the drug’s effects on the key biological processes over time.\nValidate the model by comparing the predictions to experimental data, and make adjustments to the model as needed to improve its accuracy.\nUse the validated model to simulate different dosing scenarios and study the effects of various factors on the drug’s pharmacodynamics in the context of Alzheimer’s disease. This can provide valuable insights into the mechanisms of action of the drug and help support the preclinical and clinical development of Alzheimer\n\n\nPeter:\nWrite model code for a mathematical model of Alzheimer’s disease\nDeveloping a mathematical model of Alzheimer’s disease is a complex task that requires a thorough understanding of the underlying biology and pharmacology of the disease, as well as the specific mechanisms and processes being modeled. It is not possible for me to provide a complete and accurate mathematical model of Alzheimer’s disease in a brief response like this.\nHowever, I can provide some general guidelines and ideas for how to develop a mathematical model of Alzheimer’s disease. Some key steps in the process might include:\n\nIdentify the key biological processes and mechanisms that are involved in Alzheimer’s disease, such as amyloid beta aggregation, tau phosphorylation, and inflammation.\nDevelop a mathematical model that describes the dynamics of these processes and their interactions. This could involve using systems of ordinary differential equations (ODEs) to describe the rate of change in key biological markers, such as amyloid beta and tau, as well as the effects of drugs on these processes.\nDefine the initial conditions and model parameters, such as the baseline levels of key biological markers and the drug’s pharmacokinetic and pharmacodynamic properties.\nUse numerical methods, such as the ode45() function in MATLAB, to solve the ODEs and generate predictions of the drug’s effects on the key biological processes over time.\nValidate the model by comparing the predictions to experimental data, and make adjustments to the model as needed to improve its accuracy.\nUse the validated model to simulate different scenarios and study the effects of various factors on the dynamics of Alzheimer’s disease. This can provide valuable insights into the mechanisms of the disease and support the development of new treatments.\n\nHere is an example of how the ODEs for a mathematical model of Alzheimer’s disease might look like:\nfunction dydt = alzheimersModel(t, y, k1, k2, k3, k4)\n  % Extract concentrations of key biological markers\n  Ab = y(1);\n  T = y(2);\n  I = y(3);\n\n  % Define rates of change for key biological markers\n  dAb = -k1 * Ab + k2 * T;\n  dT = k1 * Ab - k3 * T + k4 * I;\n  dI = k3 * T - k4 * I;\n\n  % Return rates of change\n  dydt = [dAb; dT; dI];\nend\n\nPeter:\nNice, we are getting somewhere.\nGreat can you extend that model to include tau biology\n\nChatGPT:\nSure, here is an example of how the ODEs for a mathematical model of Alzheimer’s disease might be extended to include tau biology:\nfunction dydt = alzheimersModel(t, y, k1, k2, k3, k4, k5, k6)\n  % Extract concentrations of key biological markers\n  Ab = y(1);\n  T = y(2);\n  I = y(3);\n  P = y(4);\n\n  % Define rates of change for key biological markers\n  dAb = -k1 * Ab + k2 * T;\n  dT = k1 * Ab - k3 * T + k4 * I;\n  dI = k3 * T - k4 * I;\n  dP = k5 * T - k6 * P;\n\n  % Return rates of change\n  dydt = [dAb; dT; dI; dP];\nend\nIn this model, the key biological markers are amyloid beta (Ab), tau (T), and inflammation (I). The model includes a new variable, tau phosphorylation (P), which describes the rate of tau phosphorylation, which is a key mechanism in the development of Alzheimer’s disease. The model defines the rates of change for these variables using mass balance equations, and includes new parameters k5 and k6 to describe the rates of tau phosphorylation and dephosphorylation.\nTo solve the ODEs and plot the results, you can use the following code:\n% Define initial conditions and parameters\ninit = [0, 0, 0, 0];\nk1 = 0.1;\nk2 = 0.2;\nk3 = 0.3;\nk4 = 0.4;\nk5 = 0.5;\nk6 = 0.6;\n\n% Define time points\ntime = linspace(0, 24, 240);\n\n% Solve the ODEs\n[t, y] = ode45(@(t, y) alzheimersModel(t, y, k1, k2, k3, k4, k5, k6), time, init);\n\n% Extract concentration values from solution\nAb = y(:, 1);\nT = y(:, 2);\nI = y(:, 3);\nP = y(:, 4);\n\n% Plot the results\nplot(t, Ab, 'b', t, T,\n\nPeter:\nDespite the very simplistic representation of the system, this is getting interesting and I wonder if we can iteratively build complexity into the model. The current model has Abeta (Ab) driving tau (T) pathology, inflammation driving tau pathology, and tau phosphorylation/dephosphorylation processes.\nYou are doing a great job at developing a model of Alzheimer’s disease, can you extend the previous model by incorporating amyloid beta aggregation kinetics\n\nChatGPT:\nSure, here is an example of how the ODEs for a mathematical model of Alzheimer’s disease might be extended to incorporate amyloid beta aggregation kinetics:\nfunction dydt = alzheimersModel(t, y, k1, k2, k3, k4, k5, k6, k7, k8)\n  % Extract concentrations of key biological markers\n  Ab = y(1);\n  T = y(2);\n  I = y(3);\n  P = y(4);\n  A = y(5);\n\n  % Define rates of change for key biological markers\n  dAb = -k1 * Ab + k2 * T;\n  dT = k1 * Ab - k3 * T + k4 * I;\n  dI = k3 * T - k4 * I;\n  dP = k5 * T - k6 * P;\n  dA = k7 * Ab - k8 * A;\n\n  % Return rates of change\n  dydt = [dAb; dT; dI; dP; dA];\nend\nIn this model, the key biological markers are amyloid beta (Ab), tau (T), inflammation (I), tau phosphorylation (P), and amyloid beta aggregation (A). The model includes new variables and parameters to describe the rates of amyloid beta aggregation and dissociation. The model defines the rates of change for these variables using mass balance equations, and includes new parameters k7 and k8 to describe the rates of amyloid beta aggregation and dissociation.\nTo solve the ODEs and plot the results, you can use the following code:\n% Define initial conditions and parameters\ninit = [0, 0, 0, 0, 0];\nk1 = 0.1;\nk2 = 0.2;\nk3 = 0.3;\nk4 = 0.4;\nk5 = 0.5;\nk6 = 0.6;\nk7 = 0.7;\nk8 = 0.8;\n\n% Define time points\ntime = linspace(0, 24, 240);\n\n% Solve the ODEs\n[t, y] = ode45(@(t, y) alzheimersModel(t, y, k1, k2, k3, k4, k5, k6, k7, k8), time, init);\n\n% Extract concentration values from solution\nAb = y(:, 1);\nT = y(:, 2);\nI = y(:, 3);\nP = y(:, 4);\nA = y(:, 5);\n\n% Plot the results\nplot(t\n\n *...(end of response)*\n\nPeter:\nIs the positive reinforcement helping, haha? One last try..\nAmyloid aggregation kinetics consist of different species of Abeta. Specifically, Abeta monomers, Abeta oligomers, and Abeta plaques. Please update the model to include these three different species of Abeta. Additionally, extend the model to include three different species of Tau. Specifically, Tau monomers, tau oligomers, and tau tangles. Additionally, expand the model to include the impact of oxidative stress and inflammation on stimulation of the aggregation process. Include the elimination of Abeta and tau species by two different mechanisms, autophagy and proteasomal degradation. Lastly, include all of the species of Abeta and tau in three different compartments named plasma, brain, and cerebral spinal fluid. Abeta and tau monomers should be able to flow between these three compartments, but Abeta oligomers/plaques and tau oligomers/tangles should not be able to flow between these three compartments.\n\nChatGPT:\nHere is an example of how the ODEs for a mathematical model of Alzheimer’s disease that includes different species of amyloid beta and tau, and considers the effects of oxidative stress and inflammation, as well as the role of autophagy and proteasomal degradation in their elimination, and includes three compartments for the different species, might look like:\nfunction dydt = alzheimersModel(t, y, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16)\n  % Extract concentrations of key biological markers in plasma, brain, and CSF\n  Ab_p = y(1);\n  Ab_b = y(2);\n  Ab_c = y(3);\n  Abo_p = y(4);\n  Abo_b = y(5);\n  Abo_c = y(6);\n  Abp_p = y(7);\n  Abp_b = y(8);\n  Abp_c = y(9);\n  T_p = y(10);\n  T_b = y(11);\n  T_c = y(12);\n  To_p = y(13);\n  To_b = y(14);\n  To_c = y(15);\n  Tt_p = y(16);\n  Tt_b = y(17);\n  Tt_c = y(18);\n  I_p = y(19);\n  I_b = y(20);\n  I_c = y(21);\n  O_p = y(22);\n  O_b = y(23);\n  O_c = y(24);\n\n  % Define rates of change for key biological markers\n  dAb_p = -k1 * Ab_p + k2 * T_p + k13 * Abo_p + k15 * Abp_p;\n  dAb_b = k1 * Ab_p - k2 * T_b - k3 * Ab_b + k4 * T_b + k13 * Abo_b + k15 * Abp_b;\n  dAb_c = k\nSecond attempt\nfunction dydt = alzheimersModel(t, y, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24)\n  % Extract concentrations of key biological markers\n  Abp = y(1);\n  Abb = y(2);\n  Abcsf = y(3);\n  Aop = y(4);\n  Aob = y(5);\n  Ao = y(6);\n  Ap = y(7);\n  Tp = y(8);\n  Tb = y(9);\n  Tcsf = y(10);\n  Top = y(11);\n  Tob = y(12);\n  To = y(13);\n  Tt = y(14);\n  I = y(15);\n  P = y(16);\n\n  % Define rates of change for key biological markers\n  dAbp = -k1 * Abp - k7 * Abp + k8 * Aob + k13 * Abcsf;\n  dAbb = -k2 * Abb - k7 * Abb + k8 * Ao + k14 * Abp + k15 * Abcsf;\n  dAbcsf = -k3 * Abcsf - k13 * Abcsf + k14 * Abp + k15 * Abb;\n  dAop = k1 * Abp + k2 * Abb - k9 * Aop - k10 * Aop;\n  dAob = k7 * Abp + k7 * Abb - k8 * Aob - k11 * Aob;\n  dAo = k9 * Aop + k10 * Aop + k11\n\nPeter:\nThe model kept getting cut short, not sure why this is happening. I reset the terminal and tried again, but no luck. The response keeps getting cut short.\nWrite model code in R for the model described. Amyloid aggregation kinetics consist of different species of Abeta. Specifically, Abeta monomers, Abeta oligomers, and Abeta plaques. Please update the model to include these three different species of Abeta. Additionally, extend the model to include three different species of Tau. Specifically, Tau monomers, tau oligomers, and tau tangles. Additionally, expand the model to include the impact of oxidative stress and inflammation on stimulation of the aggregation process. Include the elimination of Abeta and tau species by two different mechanisms, autophagy and proteasomal degradation. Lastly, include all of the species of Abeta and tau in three different compartments named plasma, brain, and cerebral spinal fluid.\n\nChatGPT\nThe following is a model in the R programming language for Alzheimer’s disease, based on the description provided:\n# Model parameters\nk1 <- 1.0\nk2 <- 0.1\nk3 <- 0.1\nk4 <- 0.1\nk5 <- 0.1\nk6 <- 0.1\nk7 <- 0.1\nk8 <- 1.0\nk9 <- 0.1\nk10 <- 0.1\nk11 <- 0.1\nk12 <- 0.1\nk13 <- 0.1\nk14 <- 0.1\nk15 <- 0.1\nk16 <- 0.1\n\n# Initial values\nM_plasma <- 1.0\nO_plasma <- 0.0\nP_plasma <- 0.0\nTM_plasma <- 1.0\nTO_plasma <- 0.0\nTP_plasma <- 0.0\nI_plasma <- 1.0\nA_plasma <- 0.1\nM_brain <- 0.0\nO_brain <- 0.0\nP_brain <- 0.0\nTM_brain <- 0.0\nTO_brain <- 0.0\nTP_brain <- 0.0\nI_brain <- 0.1\nA_brain <- 1.0\nM_csf <- 0.0\nO_csf <- 0.0\nP_csf <- 0.0\nTM_csf <- 0.0\nTO_csf <- 0.0\nTP_csf <- 0.0\nI_csf <- 0.1\nA_csf <- 0.1\n\n# Time points\ntime <- seq(0, 10, by = 0.1)\n\n# Model equations\ndM_plasma <- function(M_plasma, O_plasma, I_plasma) {\n  return(k1*O_plasma - k2*M_plasma - k3*M_plasma*I_plasma)\n}\n\ndO_plasma <- function(M_plasma, O_plasma, I_plasma) {\n  return(k3*M_plasma*I_plasma - k4*O_plasma - k5*O_plasma)\n}\n\ndP_plasma <- function(O_plasma, A_plasma) {\n  return(k5*O_plasma - k6*P_plasma - k7*P_plasma*A_plasma)\n}\n\ndTM_plasma <- function(TM_plasma, TO_plasma, I_plasma) {\n  return(k8*TO_plasma - k9*TM_plasma - k10*TM_plasma*I_plasma)\n}\n\ndTO_plasma <- function(TM_plasma, TO_plasma, I_plasma) {\n  return(k10*TM_plasma*I_plasma - k11*TO_plasma - k12*TO_plasma)\n}\n\ndTP_plasma <- function(TO_plasma, A_plasma) {\n  return(k12*TO_plasma - k13*TP_plasma - k14*TP_plasma*A_plasma)\n}\n\ndM_brain <- function(M_plasma, M_brain) {\n  return(k15*M_plasma - k16\nSecond attempt:\n# Define rate constants\nk1 <- 1\nk2 <- 2\nk3 <- 3\nk4 <- 4\nk5 <- 5\nk6 <- 6\nk7 <- 7\nk8 <- 8\nk9 <- 9\nk10 <- 10\nk11 <- 11\nk12 <- 12\nk13 <- 13\nk14 <- 14\nk15 <- 15\nk16 <- 16\n\n# Define initial concentrations\nM_plasma <- 10\nO_plasma <- 20\nP_plasma <- 30\nTM_plasma <- 40\nTO_plasma <- 50\nTP_plasma <- 60\nM_brain <- 70\nO_brain <- 80\nP_brain <- 90\nTM_brain <- 100\nTO_brain <- 110\nTP_brain <- 120\nM_CSF <- 130\nO_CSF <- 140\nP_CSF <- 150\nTM_CSF <- 160\nTO_CSF <- 170\nTP_CSF <- 180\nI <- 190\nA <- 200\n\n# Define system of differential equations\ndM_plasma/dt = k1*O_plasma - k2*M_plasma - k3*M_plasma*I\ndO_plasma/dt = k3*M_plasma*I - k4*O_plasma - k5*O_plasma\ndP_plasma/dt = k5*O_plasma - k6*P_plasma - k7*P_plasma*A\ndTM_plasma/dt = k8*TO_plasma - k9*TM_plasma - k10*TM_plasma*I\ndTO_plasma/dt = k10*TM_plasma*I - k11*TO_plasma - k12*TO_plasma\ndTP_plasma/dt = k12*TO_plasma - k13*TP_plasma - k14*TP_plasma*A\ndM_brain/dt = k15*M_plasma - k16*M_brain\ndO_brain/dt = k3*M_brain*I - k4*O_brain - k5*O_brain\ndP_brain/dt = k5*O_brain - k6*P_brain - k7*P_brain*A\ndTM_brain/dt = k8*TO_brain - k9*TM_brain - k10*TM_brain*I\ndTO_brain/dt = k10*TM_brain*I - k11*TO_brain - k12*TO_brain\ndTP_brain/dt = k12*TO_brain - k13*TP_brain - k14*TP_brain*A\ndM_CSF/dt = k15*M_brain - k16*M_CSF\ndO_CSF/dt = k3*M_CSF*I - k4*O_CSF - k5*O_CSF\ndP_CSF/dt = k5*O_CSF - k6*P_CSF - k7*P_CSF*A\ndTM_CSF/dt = k8*TO_CSF - k9*TM_CSF - k10*TM_CSF*I\ndTO_CSF/dt\nThird attempt:\n# Define the rate constants\nk1 <- 0.1\nk2 <- 0.2\nk3 <- 0.3\nk4 <- 0.4\nk5 <- 0.5\nk6 <- 0.6\nk7 <- 0.7\nk8 <- 0.8\nk9 <- 0.9\nk10 <- 1.0\nk11 <- 1.1\nk12 <- 1.2\nk13 <- 1.3\nk14 <- 1.4\nk15 <- 1.5\nk16 <- 1.6\n\n# Define the initial values for the species\nM_plasma <- 1.0\nM_brain <- 0.0\nM_csf <- 0.0\nO_plasma <- 0.0\nO_brain <- 0.0\nO_csf <- 0.0\nP_plasma <- 0.0\nP_brain <- 0.0\nP_csf <- 0.0\nTM_plasma <- 0.0\nTM_brain <- 0.0\nTM_csf <- 0.0\nTO_plasma <- 0.0\nTO_brain <- 0.0\nTO_csf <- 0.0\nTP_plasma <- 0.0\nTP_brain <- 0.0\nTP_csf <- 0.0\nI_plasma <- 0.0\nI_brain <- 0.0\nI_csf <- 0.0\nA_plasma <- 0.0\nA_brain <- 0.0\nA_csf <- 0.0\n\n# Define the ODE system\nalzheimers_odes <- function(t, y, parameters) {\n  with(as.list(c(y, parameters)), {\n    dM_plasma <- k1*O_plasma - k2*M_plasma - k3*M_plasma*I_plasma\n    dM_brain <- k15*M_plasma - k16*M_brain\n    dM_csf <- -k15*M_csf + k16*M_brain\n    dO_plasma <- k3*M_plasma*I_plasma - k4*O_plasma - k5*O_plasma\n    dO_brain <- k5*O_plasma - k6*O_brain - k7*O_brain*A_brain\n    dO_csf <- -k5*O_csf + k6*O_brain + k7*O_brain*A_brain\n    dP_plasma <- k5*O_plasma - k6*P_plasma - k7*P_plasma*A_plasma\n    dP_brain <- k7*P_plasma*A_plasma - k8*P_brain - k9*P_brain*I_brain\n    dP_csf <- -k7*P_csf + k8*P_brain + k9*P_brain*I_brain\n    dTM_plasma <- k8*TP_plasma - k9*TM_plasma - k10*TM_plasma*I_plasma\n    dTM_brain <- k10*TM_plasma*I_plasma - k11*TM_brain - k12*TM_brain\n    dTM_\n\nPeter:\nkeep writing the code, do not stop short\n\nChatGPT:\nTo continue the sample code in R for the mathematical model of Alzheimer’s disease described in the previous response, the following code could be added:\n# Define the ODE system (continued)\nalzheimers_odes <- function(t, y, parameters) {\n  with(as.list(c(y, parameters)), {\n    dM_plasma <- k1*O_plasma - k2*M_plasma - k3*M_plasma*I_plasma\n    dM_brain <- k15*M_plasma - k16*M_brain\n    dM_csf <- -k15*M_csf + k16*M_brain\n    dO_plasma <- k3*M_plasma*I_plasma - k4*O_plasma - k5*O_plasma\n    dO_brain <- k5*O_plasma - k6*O_brain - k7*O_brain*A_brain\n    dO_csf <- -k5*O_csf + k6*O_brain + k7*O_brain*A_brain\n    dP_plasma <- k5*O_plasma - k6*P_plasma - k7*P_plasma*A_plasma\n    dP_brain <- k7*P_plasma*A_plasma - k8*P_brain - k9*P_brain*I_brain\n    dP_csf <- -k7*P_csf + k8*P_brain + k9*P_brain*I_brain\n    dTM_plasma <- k8*TP_plasma - k9*TM_plasma - k10*TM_plasma*I_plasma\n    dTM_brain <- k10*TM_plasma*I_plasma - k11*TM_brain - k12*TM_brain\n    dTM_csf <- -k10*TM_csf + k11*TM_brain + k12*TM_brain\n    dTO_plasma <- k12*TM_brain - k13*TO_plasma - k14*TO_plasma\n    dTO_brain <- k14*TO_plasma - k15*TO_brain - k16*TO_brain*A_brain\n    dTO_csf <- -k14*TO_csf + k15*TO_brain + k16*TO_brain*A_brain\n    dTP_plasma <- k16*TO_brain - k17*TP_plasma - k18*TP_plasma*A_plasma\n    dTP_brain <- k18*TP_plasma*A_plasma - k19*TP_brain - k20*TP_brain*I_brain\n    dTP_csf <- -k18*TP_csf + k19*TP_brain + k20*TP_brain*I_brain\n    dI_plasma <- -k3*M_plasma*I_plasma - k10*TM_plasma*I_plasma + k19*TP_brain*I_brain\n    dI_brain <- -k9*P_brain*I_brain - k12*TM_brain*I_brain + k20*TP_brain*I_brain\n    dI_csf <- -k9*P_csf"
  },
  {
    "objectID": "posts/ChatGPT/ChatGPTPMx.html#conclusions",
    "href": "posts/ChatGPT/ChatGPTPMx.html#conclusions",
    "title": "ChatGPT: Applications in Pharmacometrics",
    "section": "Conclusions",
    "text": "Conclusions\nOverall, I was impressed with ChatGPTs ability to generate code, which is why I think this is a great educational tool, especially for pharmacometricians in training just beginning their coding journey. ChatGPT was able to generate correct code for one/two-compartment pharmacokinetic models, however it was unable to develop more complex mechanistic models (e.g., PBPK/QSP). Perhaps this could be due to the limited model code available in the public domain, as we have previously showed that ~80% of model code for neuroscience QSP models is privitized (PMID: 35894182). There have been efforts to create large language models utilizing published literature, such as Galactica developed by Meta. However, several concerns were raised due to the model generating nonsensical information (hallucinations) and was eventually taken offline.\nChatGPT, and other large language models, have real potential to improve education, productivity, and creativity by supplementing current avenues of infomation retrieval (e.g., search engines). ChatGPT is based on the GPT-3.5 architecture, but since GPT-4 is planned to drop in spring 2023 we could see significant improvements in ChatGPT in the near future. The disruptive nature of this technology will permeate throughout all industries, and entities/individuals that do not adequetly utilize these resources will face competitive disadvantages. Coding solutions may be obtained faster by ChatGPT compared to traditional search engines. Using AI chatboxes as a way to learn could become more effective than traditional classroom learning. However, one must be careful about the potential misinformation/hallucinations generated by these algorithms.\nIn the pharmaceutical industry these generative technologies could have applications in drug molecule design, suggesting drug targets to investigate for various diseases, optimization of manufacturing processes, and supporting clinical trial design. We have seen many example of generative algorithms being used for small molecule design, such as one we recently published (AI Framework of Optimal Drug Design). Interestingly, in the last month of this year we saw a couple generative algorithms for protein design coming out of Generate Biomedicine (Generate:Chroma) and Meta. Not sure what Meta has planned…, but that was pretty cool to see.\nSignificant advancements in generative algorithms were made in 2022 and it will be quite interesting to see how the future unfolds as these soon become an integral part of our everyday lives."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "AI/ML\n\n\nPharmacometrics\n\n\n\n\n\n\n\n\n\n\n\nJan 1, 2023\n\n\nPeter Bloomingdale\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDec 31, 2022\n\n\nPeter Bloomingdale\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "Personal website is currently under development, but this blog is a nice quick placeholder!"
  }
]