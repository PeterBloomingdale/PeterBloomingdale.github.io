---
title: "ChatGPT: Applications in Pharmacometrics"
author: Peter Bloomingdale
format: 
    html: 
      embed-resources: true
      code-line-numbers: true
      include-in-header:
          - text: |
              <script>
              window.MathJax = {
                  tex: {
                  tags: 'ams'
                  }
              };
              </script>
highlight-style: petervsdark.theme
toc: true
date: "2023-1-1"
categories: [AI/ML, Pharmacometrics]
image: "photo-boston-night.jpg"
---

## TLDR

*A technology as disruptive as the internet...*

ChatGPT is not quite there, but I would make this statement about **generative artifical intelligence (AI)**. ChatGPT, although far from perfect, provides a nice proof-of-concept for the power of transformer technology and large language models. I have provided the short dialog relating to applications in pharmacometrics. In short, the jobs of pharmacometricians are not in jeopardy in the near term. Perhaps the only benefit of our field being so closed-door when it comes to model/code/data sharing haha (*painfully laughing*). 

ChatGPT Summary:

1. One Compartment PK Model (Explicit) - [Fail]{style="color: red;"}
2. One Compartment PK Model (ODEs) - [Pass]{style="color: green;"}
3. Two Compartment PK Model (ODEs) - [Pass]{style="color: green;"}
4. Physiologically-Based PK Model - [Fail]{style="color: red;"}
5. Minimal Physiologically-Based PK Model - [Fail]{style="color: red;"}
6. Quantitative Systems Pharmacology Model - [Fail]{style="color: red;"}

## ChatGPT Conversion

Below is the exact dialog that I had with ChatGPT

* **Bold** is the text entered into the ChatGPT input box
* *Italics* is my commentary
* All other text is ChatGPTs response

<hr style="border:2px solid blue">

### Q1: One-Compartment PK Model

**Peter:**

**In R, write a one-compartment pharmacokinetic model**

___

**ChatGPT:**

In R, you can create a one-compartment pharmacokinetic model using the following code:

```r
# Define function for one-compartment model
oneCompartmentModel <- function(dose, k) {
  # Create empty vector to store concentrations over time
  concentrations <- c()
  
  # Set initial concentration to 0
  concentrations[1] <- 0
  
  # Loop through time points and calculate concentrations
  for (i in 2:length(time)) {
    # Calculate concentration at current time point
    concentrations[i] <- concentrations[i - 1] + dose * k * (1 - exp(-k * (time[i] - time[i - 1])))
  }
  
  # Return concentrations
  return(concentrations)
}

# Define time points and dose
time <- seq(0, 24, 0.1)
dose <- 100

# Define elimination rate constant (k)
k <- 0.1

# Run the model
concentrations <- oneCompartmentModel(dose, k)
```

This code defines a function `oneCompartmentModel()` that takes the dose and the elimination rate constant (k) as input and returns a vector of concentrations over time. The function uses a simple one-compartment model to calculate the concentrations at each time point by looping through the time points and updating the concentration at each time point based on the previous concentration and the dose and k values. The function returns the vector of concentrations, which can then be plotted or analyzed further.

___

**Peter:**

*This code executes, but the output does not make sense. See figure below*

<div style="text-align:center">
![Figure 1: ChatGPT One-Compartment Pharmacokinetic Model](1cmpk.png)
</div>

*The equation is incorrect. There are clear dimensionality problems with the equation (e.g., concentration + dose/time). The equation is explicit, does not use differential equations. Perhaps it got confused between a one-compartment PK model for IV versus oral administration, mixing up parameters for the first-order rate constant of elimination (k) and absorption (ka). One-compartment IV (equation 1) and oral absorption (equation 2) PK model equations shown below:*

\begin{equation} 
C(t) = C_{0} \cdot e^{-k \cdot t} 
\end{equation}

\begin{equation}
C(t) = \frac{F \cdot Dose \cdot k_{a}}{(k_{a} - k_{e}) \cdot V}(e^{-k_{e} \cdot t} - e^{-k_{a} \cdot t})
\end{equation} 
 
 *However, it was cool to see that a function was created, parameters/dose were defined, and a for-loop was used to generate a vector of concentrations based on input variables (dose, k). A bit surprised that the equation was explicit and differential equations were not used.*

<hr style="border:2px solid blue">

### Q2: One-Compartment PK Model (ODEs)

**Peter:**

**In R, write a one-compartment pharmacokinetic model using ODEs**

___

**ChatGPT:**

In R, you can create a one-compartment pharmacokinetic model using ordinary differential equations (ODEs) with the following code:

```r
# Define function for one-compartment model using ODEs
oneCompartmentModelODE <- function(time, init, params) {
  with(as.list(c(init, params)), {
    # Calculate rate of change in concentration
    dA <- -k * A
    
    # Return rate of change
    return(list(dA))
  })
}

# Define initial conditions and parameters (Original)
init <- c(A = 0)
params <- c(k = 0.1)


# Define initial conditions and parameters (Updated)
init <- c(A = 100)
params <- c(k = 0.1)
time <- seq(0, 24, 0.1)

# Use ode to solve the system of ODEs
output <- ode(func = oneCompartmentModelODE, y = init, times = time, parms = params)

# Extract concentration values from output
concentrations <- output[, "A"]
```

This code defines a function `oneCompartmentModelODE()` that takes the time points, initial conditions, and parameters as input and uses the `ode()` function from the `deSolve` package to solve the system of ODEs for the one-compartment model. The function returns a matrix of output values, which can then be used to extract the concentrations over time. The code then uses the `ode()` function to solve the ODEs for the specified time points and parameters, and extracts the concentrations from the output. These concentrations can then be plotted or analyzed further.

___

**Peter:**

*The code executes (with minor changes) and the equations are correct (Figure 2). The ode() function used requires the `deSolve` package to be installed. The <span style="color:green">"# Define initial conditions and parameters"</span> block needed to be updated to include the variable, which was missing in the original code. Additionally, initial concentration was set to 0, which I changed to 100. Small note the variable name "A" typically refers to an amount, but here it was defined as a concentration.*

<div style="text-align:center">
![Figure 2: ChatGPT One-Compartment Pharmacokinetic Model (ODEs)](1cmpk-ode.png)
</div>

<hr style="border:2px solid blue">

### Q3: Two-Compartment PK Model (ODEs)

**Peter:**

**In R, write a two-compartment pharmacokinetic model using ODEs**

___

**ChatGPT:**

```r
# Define function for two-compartment model using ODEs
twoCompartmentModelODE <- function(time, init, params) {
  with(as.list(c(init, params)), {
    # Calculate rate of change in concentrations in each compartment
    dA1 <- -(k12 + k10) * A1 + k21 * A2
    dA2 <- k12 * A1 - k21 * A2
    
    # Return rates of change
    # return(list(dA1, dA2)) # Original
    return(list(c(dA1, dA2))) # Updated
  })
}

# Define initial conditions and parameters (Original)
init <- c(A1 = 0, A2 = 0)
params <- c(k12 = 0.1, k21 = 0.2, k10 = 0)

# Define initial conditions and parameters (Updated)
init <- c(A1 = 100, A2 = 0)
params <- c(k12 = 0.1, k21 = 0.2, k10 = 0.1)
time <- seq(0, 24, 0.1)

# Use ode to solve the system of ODEs
output <- ode(func = twoCompartmentModelODE, y = init, times = time, parms = params)

# Extract concentration values from output
concentrations1 <- output[, "A1"]
concentrations2 <- output[, "A2"]
```

This code defines a function `twoCompartmentModelODE()` that takes the time points, initial conditions, and parameters as input and uses the `ode()` function from the `deSolve` package to solve the system of ODEs for the two-compartment model. The function returns a matrix of output values, which can then be used to extract the concentrations in each compartment over time. The code then uses the `ode()` function to solve the ODEs for the specified time points and parameters, and extracts the concentrations from the output. These concentrations can then be plotted or analyzed further.

___

**Peter:**

*This code executes (with minor changes) and the equations are correct. Again, time was not defined. The initial concentration of C1 was 0 and the rate of elimination (k10) from the central compartment was 0. These values were updated for the simulation.*

<div style="text-align:center">
![Figure 3: ChatGPT Two-Compartment Pharmacokinetic Model (ODEs)](2cmpk-ode.png)
</div>

*There was an error upon execution that I had asked ChatGPT to resolve. The error was eventually solved by concatenating the outputs in the return statement (`c(dA1, dA2)`) of the `twoCompartmentModelODE` function. However, ChatGPT was unable to resolve the error and kept providing the same response without any changes. The dialog is provided below*:

**Your code gave me the following error, please help me solve it.**

<span style="color:red; font-weight:bold">Error in checkFunc(Func2, times, y, rho):
  The number of derivatives returned by func() (1) must equal the length of the initial conditions vector (2)
Calls: ode -> lsoda -> checkFunc
Execution halted
</span>

___

**ChatGPT:** 

This error message indicates that the ode() function is expecting the twoCompartmentModelODE() function to return two values (one for each compartment), but it is only returning one value (the rate of change in the first compartment). To fix this error, you need to modify the twoCompartmentModelODE() function to return both rates of change, like this:

```r
# Define function for two-compartment model using ODEs
twoCompartmentModelODE <- function(time, init, params) {
  with(as.list(c(init, params)), {
    # Calculate rate of change in concentrations in each compartment
    dA1 <- -(k12 + k10) * A1 + k21 * A2
    dA2 <- k12 * A1 - k21 * A2
    
    # Return rates of change
    return(list(dA1, dA2))
  })
}
```

In this updated version of the function, the return() statement includes both rates of change, separated by a comma. This will ensure that the ode() function receives the correct number of values and can solve the system of ODEs correctly.

<hr style="border:2px solid blue">

### Q4: Physiologically-Based Pharmacokinetic (PBPK) Model

**Peter:**

**In R, code a physiologically-based pharmacokinetic model**

___

**ChatGPT:**

In R, you can create a physiologically-based pharmacokinetic (PBPK) model using the following code:

```r
# Define function for PBPK model
pbpkModel <- function(time, init, params) {
  with(as.list(c(init, params)), {
    # Calculate rate of change in concentrations in each compartment
    dA1 <- -(k12 + k10) * A1 + k21 * A2
    dA2 <- k12 * A1 - k21 * A2
    
    # Calculate liver and kidney clearance
    liverClearance <- Q * kLiver
    kidneyClearance <- Q * kKidney
    
    # Calculate rate of change in drug amount in liver and kidneys
    dLiver <- liverClearance - k10 * A1
    dKidney <- kidneyClearance - k10 * A2
    
    # Return rates of change
    #return(list(dA1, dA2, dLiver, dKidney)) # Original
    return(list(c(dA1, dA2, dLiver, dKidney))) # Updated
  })
}

# Define initial conditions and parameters (Original)
init <- c(A1 = 0, A2 = 0, liver = 0, kidney = 0)
params <- c(k12 = 0.1, k21 = 0.2, k10 = 0, kLiver = 0.3, kKidney = 0.4, Q = 1)

# Define initial conditions and parameters (Updated)
init <- c(A1 = 100, A2 = 0, liver = 0, kidney = 0)
params <- c(k12 = 0.1, k21 = 0.2, k10 = 0.1, kLiver = 0.3, kKidney = 0.4, Q = 1)
time <- seq(0, 24, 0.1)

# Use ode to solve the system of ODEs
output <- ode(func = pbpkModel, y = init, times = time, parms = params)

# Extract concentration values from output
concentrations1 <- output[, "A1"]
concentrations2 <- output[, "A2"]
liverConcentrations <- output[, "liver"]
kidneyConcentrations <- output[, "kidney"]
```

This code defines a function `pbpkModel()` that takes the time points, initial conditions, and parameters as input and uses the `ode()` function from the `deSolve` package to solve the system of ODEs for the PBPK model. The function calculates the rates of change in the concentrations in each compartment, as well as the liver and kidney clearances and the amounts of drug in the liver and kidneys. It then returns these values, which can be used by the `ode()` function to solve the ODEs. The code then uses the `ode()` function to solve the ODEs for the specified time points and parameters, and extracts the concentrations and drug amounts from the output. These values can then be plotted or analyzed further.

___

**Peter:**

*This code executes (with minor changes), but the equations are <span style="color:red">incorrect</span>. Time was not defined and initial conditions needed to be initialized, values were updated for the simulation. The same error, which requires concatenating the outputs in the return statement needed to be resolved. The PBPK model generated by ChatGPT is essentially a two-compartment model with a kidney and liver compartment added. However, the liver and kidney equations are completely off and do not make sense. The simulations resulted in negative concentrations in liver and kidney compartments. Quite disappointing...*

<div style="text-align:center">
![Figure 4: ChatGPT Physiologically-Based Pharmacokinetic Model](pbpk.png)
</div>

<hr style="border:2px solid blue">

### Q5: Minimal Brain Physiologically-Based Pharmacokinetic (PBPK) Model

**Peter:**

*Perhaps being more specific on the type of PBPK model could help. Also wondering if it was trained using the scientific literature. In one of my papers ([minimal brain PBPK model](https://link.springer.com/content/pdf/10.1007/s10928-021-09776-7.pdf?pdf=button)) I have published the [model code](https://static-content.springer.com/esm/art%3A10.1007%2Fs10928-021-09776-7/MediaObjects/10928_2021_9776_MOESM1_ESM.zip) in the supplementary information, but I doubt that was used. Lets find out. We will have to ask it to code it in MATLAB as well.

**In R, code a minimal brain physiologically-based pharmacokinetic (PBPK) model that can be used to to support the preclinical and clinical development of antibody therapeutics for CNS diseases**

___ 

**ChatGPT**

In R, you can create a minimal brain physiologically-based pharmacokinetic (PBPK) model using the following code:

```r
# Define function for PBPK model
pbpkModel <- function(time, init, params) {
  with(as.list(c(init, params)), {
    # Calculate rate of change in concentrations in each compartment
    dA1 <- -(k12 + k10) * A1 + k21 * A2
    dA2 <- k12 * A1 - k21 * A2
    dBrain <- -k10 * ABrain + k21 * CBrain
    
    # Calculate liver and kidney clearance
    liverClearance <- Q * kLiver
    kidneyClearance <- Q * kKidney
    
    # Calculate rate of change in drug amount in liver and kidneys
    dLiver <- liverClearance - k10 * A1
    dKidney <- kidneyClearance - k10 * A2
    
    # Return rates of change
    return(list(dA1, dA2, dBrain, dLiver, dKidney))
  })
}

# Define initial conditions and parameters
init <- c(A1 = 0, A2 = 0, ABrain = 0, liver = 0, kidney = 0)
params <- c(k12 = 0.1, k21 = 0.2, k10 = 0, kLiver = 0.3, kKidney = 0.4, Q = 1)

# Use ode to solve the system of ODEs
output <- ode(func = pbpkModel, y = init, times = time, parms = params)

# Extract concentration values from output
concentrations1 <- output[, "A1"]
concentrations2 <- output[, "A2"]
brainConcentrations <- output[, "ABrain"]
liverConcentrations <- output[, "liver"]
kidneyConcentrations <- output[, "kidney"]
```

This code defines a function `pbpkModel()` that takes the time points, initial conditions, and parameters as input and uses the `ode()` function from the `deSolve` package to solve the system of ODEs for the PBPK model. The function calculates the rates of change in the concentrations in each compartment, as well as the liver and kidney clearances and the amounts of drug in the liver and kidneys. It also includes a compartment for the brain, and calculates the rate of change in drug concentration in the brain based on the drug concentrations in the other compartments. It then returns these values, which can be used by the `ode()` function to solve the ODEs. The code then uses the `ode()` function to solve the ODEs for the specified time points and parameters, and extracts the concentrations and drug amounts from the output. These values can then be plotted or analyzed further.

___

**Peter:**

*Okay, real bad... lol. It appears that the previous PBPK model that ChatGPT generated was extended to include a differential equation for the brain that has terms in both amounts and concentrations. How about MATLAB?

**In R, code a minimal brain physiologically-based pharmacokinetic (PBPK) model that can be used to to support the preclinical and clinical development of antibody therapeutics for CNS diseases**

___

**ChatGPT:**

In MATLAB, you can create a minimal brain physiologically-based pharmacokinetic (PBPK) model using the following code:

```r
function dydt = pbpkModel(t, y, k12, k21, k10, kLiver, kKidney, Q)
  % Calculate concentrations in each compartment
  A1 = y(1);
  A2 = y(2);
  ABrain = y(3);

  % Calculate rate of change in concentrations in each compartment
  dA1 = -(k12 + k10) * A1 + k21 * A2;
  dA2 = k12 * A1 - k21 * A2;
  dBrain = -k10 * ABrain + k21 * CBrain;

  % Calculate liver and kidney clearance
  liverClearance = Q * kLiver;
  kidneyClearance = Q * kKidney;

  % Calculate rate of change in drug amount in liver and kidneys
  dLiver = liverClearance - k10 * A1;
  dKidney = kidneyClearance - k10 * A2;

  % Return rates of change
  dydt = [dA1; dA2; dBrain; dLiver; dKidney];
end
```

This code defines a function `pbpkModel()` that takes the time points, initial conditions, and model parameters as input and calculates the rates of change in the concentrations in each compartment. It also includes a compartment for the brain, and calculates the rate of change in drug concentration in the brain based on the drug concentrations in the other compartments. The function returns the rates of change, which can then be used by the `ode45()` function in MATLAB to solve the ODEs.

To solve the ODEs and plot the results, you can use the following code:

```r
% Define initial conditions and parameters
init = [0, 0, 0];
k12 = 0.1;
k21 = 0.2;
k10 = 0;
kLiver = 0.3;
kKidney = 0.4;
Q = 1;

% Define time points
time = linspace(0, 24, 240);

% Solve the ODEs
[t, y] = ode45(@(t, y) pbpkModel(t, y, k12, k21, k10, kLiver, kKidney, Q), time, init);

% Extract concentration values from solution
A1 = y(:, 1);
A2 = y(:, 2);
ABrain = y(:, 3);

% Plot the results
plot(t, A1, 'b', t, A2, 'r', t, ABrain, 'g');
xlabel('Time (hours)');
ylabel('Concentration (mg/L)');
legend('Compartment 1', 'Compartment 2', 'Brain');
```

This code defines the initial conditions and model parameters, and uses the `ode45()` function to solve the ODEs for the specified time points. It then extracts the concentrations in each compartment from the solution and plots them using the `plot()` function. The resulting plot shows the concentrations in each compartment over time.

___

**Peter:**

*Very disappointing, but at least ChatGPT appologized...*

**This is very incorrect code, can you develop a better physiologically-based pharmacokinetic model of the brain in any language**

___

**ChatGPT:**

I apologize if the previous code was not correct or complete. Developing a physiologically-based pharmacokinetic (PBPK) model of the brain is a complex task that requires a thorough understanding of the underlying physiology and pharmacokinetic principles, as well as the specific drug being modeled and its mechanism of action. It is not possible for me to provide a complete and accurate PBPK model of the brain in a brief response like this.

However, I can provide some general guidelines and ideas for how to develop a PBPK model of the brain. Some key steps in the process might include:

1. Identify the compartments and pathways that are relevant to the brain, including the blood-brain barrier, cerebrospinal fluid, and other key anatomical structures.
2. Develop a system of ordinary differential equations (ODEs) that describes the transfer of the drug between these compartments and the body as a whole. This will typically involve using mass balance equations to describe the rate of change in drug concentration in each compartment.
3. Define the initial conditions and model parameters, such as the drug's distribution and elimination rates, and the characteristics of the compartments and pathways.
4. Use numerical methods, such as the ode45() function in MATLAB, to solve the ODEs and generate predictions of the drug's concentration in the brain over time.
5. Validate the model by comparing the predictions to experimental data, and make adjustments to the model as needed to improve its accuracy.
6. Use the validated model to simulate different dosing scenarios and study the effects of various factors on the drug's pharmacokinetics in the brain. This can provide valuable insights into the drug's pharmacokinetics and help support the preclinical and clinical development of brain-targeted therapies.

Ultimately, the development of a PBPK model of the brain will require a deep understanding of the relevant physiology, pharmacokinetics, and drug properties, as (*end of response*)

<hr style="border:2px solid blue">

### Question 6: Quantitative Systems Pharmacology (QSP) Model

**Peter:**

*Quite the long shot, but I am curious how far it gets*

**Code a quantiative systems pharmacology (QSP) model of Alzheimer's disease**

___

**ChatGPT**

Developing a quantitative systems pharmacology (QSP) model of Alzheimer's disease is a complex task that requires a thorough understanding of the underlying biology and pharmacology of the disease, as well as the specific drugs and mechanisms of action being modeled. It is not possible for me to provide a complete and accurate QSP model of Alzheimer's disease in a brief response like this.

However, I can provide some general guidelines and ideas for how to develop a QSP model of Alzheimer's disease. Some key steps in the process might include:

1. Identify the key biological pathways and mechanisms involved in Alzheimer's disease, such as the accumulation of beta-amyloid plaques and the dysregulation of neurotransmitter systems.
2. Develop a systems-level mathematical model that describes the interactions and feedback loops between these pathways and mechanisms. This will typically involve using ordinary or partial differential equations to describe the dynamics of the key variables and parameters in the model.
3. Define the initial conditions and model parameters, such as the rates of production and clearance of beta-amyloid, the levels of neurotransmitters, and the effects of genetic and environmental factors on the disease.
4. Use numerical methods, such as the ode45() function in MATLAB, to solve the equations and generate predictions of the disease's progression over time.
5. Validate the model by comparing the predictions to experimental data, and make adjustments to the model as needed to improve its accuracy.

___

**Peter:** 

**Try your best at developing model code for a quantitative systems pharmacology model of Alzheimer's disease using differential equations**

__ 

**ChatGPT**

Developing a quantitative systems pharmacology (QSP) model of Alzheimer's disease using differential equations is a complex task that requires a thorough understanding of the underlying biology and pharmacology of the disease, as well as the specific drugs and mechanisms being modeled. It is not possible for me to provide a complete and accurate QSP model of Alzheimer's disease in a brief response like this.

However, I can provide some general guidelines and ideas for how to develop a QSP model of Alzheimer's disease using differential equations. Some key steps in the process might include:

1. Identify the key biological processes and mechanisms that are involved in Alzheimer's disease, such as amyloid beta aggregation, tau phosphorylation, and inflammation.

2. Develop a system of ordinary differential equations (ODEs) that describes the dynamics of these processes and their interactions. This could involve using mass balance equations to describe the rate of change in key biological markers, such as amyloid beta and tau, as well as the effects of drugs on these processes.

3. Define the initial conditions and model parameters, such as the baseline levels of key biological markers and the drug's pharmacokinetic and pharmacodynamic properties.

4. Use numerical methods, such as the ode45() function in MATLAB, to solve the ODEs and generate predictions of the drug's effects on the key biological processes over time.

5. Validate the model by comparing the predictions to experimental data, and make adjustments to the model as needed to improve its accuracy.

6. Use the validated model to simulate different dosing scenarios and study the effects of various factors on the drug's pharmacodynamics in the context of Alzheimer's disease. This can provide valuable insights into the mechanisms of action of the drug and help support the preclinical and clinical development of Alzheimer

___ 

**Peter:**

**Write model code for a mathematical model of Alzheimer's disease**

Developing a mathematical model of Alzheimer's disease is a complex task that requires a thorough understanding of the underlying biology and pharmacology of the disease, as well as the specific mechanisms and processes being modeled. It is not possible for me to provide a complete and accurate mathematical model of Alzheimer's disease in a brief response like this.

However, I can provide some general guidelines and ideas for how to develop a mathematical model of Alzheimer's disease. Some key steps in the process might include:

1. Identify the key biological processes and mechanisms that are involved in Alzheimer's disease, such as amyloid beta aggregation, tau phosphorylation, and inflammation.

2. Develop a mathematical model that describes the dynamics of these processes and their interactions. This could involve using systems of ordinary differential equations (ODEs) to describe the rate of change in key biological markers, such as amyloid beta and tau, as well as the effects of drugs on these processes.

3. Define the initial conditions and model parameters, such as the baseline levels of key biological markers and the drug's pharmacokinetic and pharmacodynamic properties.

4. Use numerical methods, such as the ode45() function in MATLAB, to solve the ODEs and generate predictions of the drug's effects on the key biological processes over time.

5. Validate the model by comparing the predictions to experimental data, and make adjustments to the model as needed to improve its accuracy.

6. Use the validated model to simulate different scenarios and study the effects of various factors on the dynamics of Alzheimer's disease. This can provide valuable insights into the mechanisms of the disease and support the development of new treatments.

Here is an example of how the ODEs for a mathematical model of Alzheimer's disease might look like:

```r
function dydt = alzheimersModel(t, y, k1, k2, k3, k4)
  % Extract concentrations of key biological markers
  Ab = y(1);
  T = y(2);
  I = y(3);

  % Define rates of change for key biological markers
  dAb = -k1 * Ab + k2 * T;
  dT = k1 * Ab - k3 * T + k4 * I;
  dI = k3 * T - k4 * I;

  % Return rates of change
  dydt = [dAb; dT; dI];
end
```

___

**Peter:**

*Nice, we are getting somewhere.*

**Great can you extend that model to include tau biology**

___

**ChatGPT:**

Sure, here is an example of how the ODEs for a mathematical model of Alzheimer's disease might be extended to include tau biology:

```r
function dydt = alzheimersModel(t, y, k1, k2, k3, k4, k5, k6)
  % Extract concentrations of key biological markers
  Ab = y(1);
  T = y(2);
  I = y(3);
  P = y(4);

  % Define rates of change for key biological markers
  dAb = -k1 * Ab + k2 * T;
  dT = k1 * Ab - k3 * T + k4 * I;
  dI = k3 * T - k4 * I;
  dP = k5 * T - k6 * P;

  % Return rates of change
  dydt = [dAb; dT; dI; dP];
end
```

In this model, the key biological markers are amyloid beta (Ab), tau (T), and inflammation (I). The model includes a new variable, tau phosphorylation (P), which describes the rate of tau phosphorylation, which is a key mechanism in the development of Alzheimer's disease. The model defines the rates of change for these variables using mass balance equations, and includes new parameters `k5` and `k6` to describe the rates of tau phosphorylation and dephosphorylation.

To solve the ODEs and plot the results, you can use the following code:

```r
% Define initial conditions and parameters
init = [0, 0, 0, 0];
k1 = 0.1;
k2 = 0.2;
k3 = 0.3;
k4 = 0.4;
k5 = 0.5;
k6 = 0.6;

% Define time points
time = linspace(0, 24, 240);

% Solve the ODEs
[t, y] = ode45(@(t, y) alzheimersModel(t, y, k1, k2, k3, k4, k5, k6), time, init);

% Extract concentration values from solution
Ab = y(:, 1);
T = y(:, 2);
I = y(:, 3);
P = y(:, 4);

% Plot the results
plot(t, Ab, 'b', t, T,
```
___

**Peter:**

*Despite the very simplistic representation of the system, this is getting interesting and I wonder if we can iteratively build complexity into the model. The current model has Abeta (Ab) driving tau (T) pathology, inflammation driving tau pathology, and tau phosphorylation/dephosphorylation processes.*

**You are doing a great job at developing a model of Alzheimer's disease, can you extend the previous model by incorporating amyloid beta aggregation kinetics**

___ 

**ChatGPT:**

Sure, here is an example of how the ODEs for a mathematical model of Alzheimer's disease might be extended to incorporate amyloid beta aggregation kinetics:

```r
function dydt = alzheimersModel(t, y, k1, k2, k3, k4, k5, k6, k7, k8)
  % Extract concentrations of key biological markers
  Ab = y(1);
  T = y(2);
  I = y(3);
  P = y(4);
  A = y(5);

  % Define rates of change for key biological markers
  dAb = -k1 * Ab + k2 * T;
  dT = k1 * Ab - k3 * T + k4 * I;
  dI = k3 * T - k4 * I;
  dP = k5 * T - k6 * P;
  dA = k7 * Ab - k8 * A;

  % Return rates of change
  dydt = [dAb; dT; dI; dP; dA];
end
```

In this model, the key biological markers are amyloid beta (Ab), tau (T), inflammation (I), tau phosphorylation (P), and amyloid beta aggregation (A). The model includes new variables and parameters to describe the rates of amyloid beta aggregation and dissociation. The model defines the rates of change for these variables using mass balance equations, and includes new parameters k7 and k8 to describe the rates of amyloid beta aggregation and dissociation.

To solve the ODEs and plot the results, you can use the following code:

```r
% Define initial conditions and parameters
init = [0, 0, 0, 0, 0];
k1 = 0.1;
k2 = 0.2;
k3 = 0.3;
k4 = 0.4;
k5 = 0.5;
k6 = 0.6;
k7 = 0.7;
k8 = 0.8;

% Define time points
time = linspace(0, 24, 240);

% Solve the ODEs
[t, y] = ode45(@(t, y) alzheimersModel(t, y, k1, k2, k3, k4, k5, k6, k7, k8), time, init);

% Extract concentration values from solution
Ab = y(:, 1);
T = y(:, 2);
I = y(:, 3);
P = y(:, 4);
A = y(:, 5);

% Plot the results
plot(t

 *...(end of response)*
```
___

**Peter:**

*Is the positive reinforcement helping, haha? One last try..*

**Amyloid aggregation kinetics consist of different species of Abeta. Specifically, Abeta monomers, Abeta oligomers, and Abeta plaques. Please update the model to include these three different species of Abeta. Additionally, extend the model to include three different species of Tau. Specifically, Tau monomers, tau oligomers, and tau tangles. Additionally, expand the model to include the impact of oxidative stress and inflammation on stimulation of the aggregation process. Include the elimination of Abeta and tau species by two different mechanisms, autophagy and proteasomal degradation. Lastly, include all of the species of Abeta and tau in three different compartments named plasma, brain, and cerebral spinal fluid. Abeta and tau monomers should be able to flow between these three compartments, but Abeta oligomers/plaques and tau oligomers/tangles should not be able to flow between these three compartments.**

___

**ChatGPT:**

Here is an example of how the ODEs for a mathematical model of Alzheimer's disease that includes different species of amyloid beta and tau, and considers the effects of oxidative stress and inflammation, as well as the role of autophagy and proteasomal degradation in their elimination, and includes three compartments for the different species, might look like:

```r
function dydt = alzheimersModel(t, y, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16)
  % Extract concentrations of key biological markers in plasma, brain, and CSF
  Ab_p = y(1);
  Ab_b = y(2);
  Ab_c = y(3);
  Abo_p = y(4);
  Abo_b = y(5);
  Abo_c = y(6);
  Abp_p = y(7);
  Abp_b = y(8);
  Abp_c = y(9);
  T_p = y(10);
  T_b = y(11);
  T_c = y(12);
  To_p = y(13);
  To_b = y(14);
  To_c = y(15);
  Tt_p = y(16);
  Tt_b = y(17);
  Tt_c = y(18);
  I_p = y(19);
  I_b = y(20);
  I_c = y(21);
  O_p = y(22);
  O_b = y(23);
  O_c = y(24);

  % Define rates of change for key biological markers
  dAb_p = -k1 * Ab_p + k2 * T_p + k13 * Abo_p + k15 * Abp_p;
  dAb_b = k1 * Ab_p - k2 * T_b - k3 * Ab_b + k4 * T_b + k13 * Abo_b + k15 * Abp_b;
  dAb_c = k
```

*Second attempt*


```r
function dydt = alzheimersModel(t, y, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11, k12, k13, k14, k15, k16, k17, k18, k19, k20, k21, k22, k23, k24)
  % Extract concentrations of key biological markers
  Abp = y(1);
  Abb = y(2);
  Abcsf = y(3);
  Aop = y(4);
  Aob = y(5);
  Ao = y(6);
  Ap = y(7);
  Tp = y(8);
  Tb = y(9);
  Tcsf = y(10);
  Top = y(11);
  Tob = y(12);
  To = y(13);
  Tt = y(14);
  I = y(15);
  P = y(16);

  % Define rates of change for key biological markers
  dAbp = -k1 * Abp - k7 * Abp + k8 * Aob + k13 * Abcsf;
  dAbb = -k2 * Abb - k7 * Abb + k8 * Ao + k14 * Abp + k15 * Abcsf;
  dAbcsf = -k3 * Abcsf - k13 * Abcsf + k14 * Abp + k15 * Abb;
  dAop = k1 * Abp + k2 * Abb - k9 * Aop - k10 * Aop;
  dAob = k7 * Abp + k7 * Abb - k8 * Aob - k11 * Aob;
  dAo = k9 * Aop + k10 * Aop + k11
```

___

**Peter:**

*The model kept getting cut short, not sure why this is happening. I reset the terminal and tried again, but no luck. The response keeps getting cut short.*

**Write model code in R for the model described. Amyloid aggregation kinetics consist of different species of Abeta. Specifically, Abeta monomers, Abeta oligomers, and Abeta plaques. Please update the model to include these three different species of Abeta. Additionally, extend the model to include three different species of Tau. Specifically, Tau monomers, tau oligomers, and tau tangles. Additionally, expand the model to include the impact of oxidative stress and inflammation on stimulation of the aggregation process. Include the elimination of Abeta and tau species by two different mechanisms, autophagy and proteasomal degradation. Lastly, include all of the species of Abeta and tau in three different compartments named plasma, brain, and cerebral spinal fluid.**

___ 

**ChatGPT**

The following is a model in the R programming language for Alzheimer's disease, based on the description provided:

```r
# Model parameters
k1 <- 1.0
k2 <- 0.1
k3 <- 0.1
k4 <- 0.1
k5 <- 0.1
k6 <- 0.1
k7 <- 0.1
k8 <- 1.0
k9 <- 0.1
k10 <- 0.1
k11 <- 0.1
k12 <- 0.1
k13 <- 0.1
k14 <- 0.1
k15 <- 0.1
k16 <- 0.1

# Initial values
M_plasma <- 1.0
O_plasma <- 0.0
P_plasma <- 0.0
TM_plasma <- 1.0
TO_plasma <- 0.0
TP_plasma <- 0.0
I_plasma <- 1.0
A_plasma <- 0.1
M_brain <- 0.0
O_brain <- 0.0
P_brain <- 0.0
TM_brain <- 0.0
TO_brain <- 0.0
TP_brain <- 0.0
I_brain <- 0.1
A_brain <- 1.0
M_csf <- 0.0
O_csf <- 0.0
P_csf <- 0.0
TM_csf <- 0.0
TO_csf <- 0.0
TP_csf <- 0.0
I_csf <- 0.1
A_csf <- 0.1

# Time points
time <- seq(0, 10, by = 0.1)

# Model equations
dM_plasma <- function(M_plasma, O_plasma, I_plasma) {
  return(k1*O_plasma - k2*M_plasma - k3*M_plasma*I_plasma)
}

dO_plasma <- function(M_plasma, O_plasma, I_plasma) {
  return(k3*M_plasma*I_plasma - k4*O_plasma - k5*O_plasma)
}

dP_plasma <- function(O_plasma, A_plasma) {
  return(k5*O_plasma - k6*P_plasma - k7*P_plasma*A_plasma)
}

dTM_plasma <- function(TM_plasma, TO_plasma, I_plasma) {
  return(k8*TO_plasma - k9*TM_plasma - k10*TM_plasma*I_plasma)
}

dTO_plasma <- function(TM_plasma, TO_plasma, I_plasma) {
  return(k10*TM_plasma*I_plasma - k11*TO_plasma - k12*TO_plasma)
}

dTP_plasma <- function(TO_plasma, A_plasma) {
  return(k12*TO_plasma - k13*TP_plasma - k14*TP_plasma*A_plasma)
}

dM_brain <- function(M_plasma, M_brain) {
  return(k15*M_plasma - k16
```

*Second attempt:*

```r
# Define rate constants
k1 <- 1
k2 <- 2
k3 <- 3
k4 <- 4
k5 <- 5
k6 <- 6
k7 <- 7
k8 <- 8
k9 <- 9
k10 <- 10
k11 <- 11
k12 <- 12
k13 <- 13
k14 <- 14
k15 <- 15
k16 <- 16

# Define initial concentrations
M_plasma <- 10
O_plasma <- 20
P_plasma <- 30
TM_plasma <- 40
TO_plasma <- 50
TP_plasma <- 60
M_brain <- 70
O_brain <- 80
P_brain <- 90
TM_brain <- 100
TO_brain <- 110
TP_brain <- 120
M_CSF <- 130
O_CSF <- 140
P_CSF <- 150
TM_CSF <- 160
TO_CSF <- 170
TP_CSF <- 180
I <- 190
A <- 200

# Define system of differential equations
dM_plasma/dt = k1*O_plasma - k2*M_plasma - k3*M_plasma*I
dO_plasma/dt = k3*M_plasma*I - k4*O_plasma - k5*O_plasma
dP_plasma/dt = k5*O_plasma - k6*P_plasma - k7*P_plasma*A
dTM_plasma/dt = k8*TO_plasma - k9*TM_plasma - k10*TM_plasma*I
dTO_plasma/dt = k10*TM_plasma*I - k11*TO_plasma - k12*TO_plasma
dTP_plasma/dt = k12*TO_plasma - k13*TP_plasma - k14*TP_plasma*A
dM_brain/dt = k15*M_plasma - k16*M_brain
dO_brain/dt = k3*M_brain*I - k4*O_brain - k5*O_brain
dP_brain/dt = k5*O_brain - k6*P_brain - k7*P_brain*A
dTM_brain/dt = k8*TO_brain - k9*TM_brain - k10*TM_brain*I
dTO_brain/dt = k10*TM_brain*I - k11*TO_brain - k12*TO_brain
dTP_brain/dt = k12*TO_brain - k13*TP_brain - k14*TP_brain*A
dM_CSF/dt = k15*M_brain - k16*M_CSF
dO_CSF/dt = k3*M_CSF*I - k4*O_CSF - k5*O_CSF
dP_CSF/dt = k5*O_CSF - k6*P_CSF - k7*P_CSF*A
dTM_CSF/dt = k8*TO_CSF - k9*TM_CSF - k10*TM_CSF*I
dTO_CSF/dt
```

*Third attempt:*

```r
# Define the rate constants
k1 <- 0.1
k2 <- 0.2
k3 <- 0.3
k4 <- 0.4
k5 <- 0.5
k6 <- 0.6
k7 <- 0.7
k8 <- 0.8
k9 <- 0.9
k10 <- 1.0
k11 <- 1.1
k12 <- 1.2
k13 <- 1.3
k14 <- 1.4
k15 <- 1.5
k16 <- 1.6

# Define the initial values for the species
M_plasma <- 1.0
M_brain <- 0.0
M_csf <- 0.0
O_plasma <- 0.0
O_brain <- 0.0
O_csf <- 0.0
P_plasma <- 0.0
P_brain <- 0.0
P_csf <- 0.0
TM_plasma <- 0.0
TM_brain <- 0.0
TM_csf <- 0.0
TO_plasma <- 0.0
TO_brain <- 0.0
TO_csf <- 0.0
TP_plasma <- 0.0
TP_brain <- 0.0
TP_csf <- 0.0
I_plasma <- 0.0
I_brain <- 0.0
I_csf <- 0.0
A_plasma <- 0.0
A_brain <- 0.0
A_csf <- 0.0

# Define the ODE system
alzheimers_odes <- function(t, y, parameters) {
  with(as.list(c(y, parameters)), {
    dM_plasma <- k1*O_plasma - k2*M_plasma - k3*M_plasma*I_plasma
    dM_brain <- k15*M_plasma - k16*M_brain
    dM_csf <- -k15*M_csf + k16*M_brain
    dO_plasma <- k3*M_plasma*I_plasma - k4*O_plasma - k5*O_plasma
    dO_brain <- k5*O_plasma - k6*O_brain - k7*O_brain*A_brain
    dO_csf <- -k5*O_csf + k6*O_brain + k7*O_brain*A_brain
    dP_plasma <- k5*O_plasma - k6*P_plasma - k7*P_plasma*A_plasma
    dP_brain <- k7*P_plasma*A_plasma - k8*P_brain - k9*P_brain*I_brain
    dP_csf <- -k7*P_csf + k8*P_brain + k9*P_brain*I_brain
    dTM_plasma <- k8*TP_plasma - k9*TM_plasma - k10*TM_plasma*I_plasma
    dTM_brain <- k10*TM_plasma*I_plasma - k11*TM_brain - k12*TM_brain
    dTM_
```

___

**Peter:**

**keep writing the code, do not stop short**

___

**ChatGPT:**

To continue the sample code in R for the mathematical model of Alzheimer's disease described in the previous response, the following code could be added:

```r
# Define the ODE system (continued)
alzheimers_odes <- function(t, y, parameters) {
  with(as.list(c(y, parameters)), {
    dM_plasma <- k1*O_plasma - k2*M_plasma - k3*M_plasma*I_plasma
    dM_brain <- k15*M_plasma - k16*M_brain
    dM_csf <- -k15*M_csf + k16*M_brain
    dO_plasma <- k3*M_plasma*I_plasma - k4*O_plasma - k5*O_plasma
    dO_brain <- k5*O_plasma - k6*O_brain - k7*O_brain*A_brain
    dO_csf <- -k5*O_csf + k6*O_brain + k7*O_brain*A_brain
    dP_plasma <- k5*O_plasma - k6*P_plasma - k7*P_plasma*A_plasma
    dP_brain <- k7*P_plasma*A_plasma - k8*P_brain - k9*P_brain*I_brain
    dP_csf <- -k7*P_csf + k8*P_brain + k9*P_brain*I_brain
    dTM_plasma <- k8*TP_plasma - k9*TM_plasma - k10*TM_plasma*I_plasma
    dTM_brain <- k10*TM_plasma*I_plasma - k11*TM_brain - k12*TM_brain
    dTM_csf <- -k10*TM_csf + k11*TM_brain + k12*TM_brain
    dTO_plasma <- k12*TM_brain - k13*TO_plasma - k14*TO_plasma
    dTO_brain <- k14*TO_plasma - k15*TO_brain - k16*TO_brain*A_brain
    dTO_csf <- -k14*TO_csf + k15*TO_brain + k16*TO_brain*A_brain
    dTP_plasma <- k16*TO_brain - k17*TP_plasma - k18*TP_plasma*A_plasma
    dTP_brain <- k18*TP_plasma*A_plasma - k19*TP_brain - k20*TP_brain*I_brain
    dTP_csf <- -k18*TP_csf + k19*TP_brain + k20*TP_brain*I_brain
    dI_plasma <- -k3*M_plasma*I_plasma - k10*TM_plasma*I_plasma + k19*TP_brain*I_brain
    dI_brain <- -k9*P_brain*I_brain - k12*TM_brain*I_brain + k20*TP_brain*I_brain
    dI_csf <- -k9*P_csf
```

## Conclusions

Overall, I was impressed with ChatGPTs ability to generate code, which is why I think this is a great educational tool, especially for pharmacometricians in training just beginning their coding journey. ChatGPT was able to generate correct code for one/two-compartment pharmacokinetic models, however it was unable to develop more complex mechanistic models (e.g., PBPK/QSP). Perhaps this could be due to the limited model code available in the public domain, as we have previously showed that ~80% of model code for neuroscience QSP models is privitized ([PMID: 35894182](https://ascpt.onlinelibrary.wiley.com/doi/full/10.1002/psp4.12852)). There have been efforts to create large language models utilizing published literature, such as [Galactica](https://arxiv.org/abs/2211.09085) developed by Meta. However, several concerns were raised due to the model generating nonsensical information (hallucinations) and was eventually taken offline. 

ChatGPT, and other large language models, have real potential to improve education, productivity, and creativity by supplementing current avenues of infomation retrieval (e.g., search engines). ChatGPT is based on the GPT-3.5 architecture, but since GPT-4 is planned to drop in spring 2023 we could see significant improvements in ChatGPT in the near future. The disruptive nature of this technology will permeate throughout all industries, and entities/individuals that do not adequetly utilize these resources will face competitive disadvantages. Coding solutions may be obtained faster by ChatGPT compared to traditional search engines. Using AI chatboxes as a way to learn could become more effective than traditional classroom learning. However, one must be careful about the potential misinformation/hallucinations generated by these algorithms. 

In the pharmaceutical industry these generative technologies could have applications in drug molecule design, suggesting drug targets to investigate for various diseases, optimization of manufacturing processes, and supporting clinical trial design. We have seen many example of generative algorithms being used for small molecule design, such as one we recently published [(AI Framework of Optimal Drug Design)](https://www.biorxiv.org/content/10.1101/2022.10.29.514379v1.full.pdf). Interestingly, in the last month of this year we saw a couple generative algorithms for protein design coming out of Generate Biomedicine ([Generate:Chroma](https://www.biorxiv.org/content/10.1101/2022.12.01.518682v1.full.pdf)) and [Meta](https://www.biorxiv.org/content/10.1101/2022.12.21.521526v1.full.pdf). Not sure what Meta has planned..., but that was pretty cool to see.

Significant advancements in generative algorithms were made in 2022 and it will be quite interesting to see how the future unfolds as these soon become an integral part of our everyday lives.